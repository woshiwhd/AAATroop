# 工程实现逻辑结构

## 一、整体架构层级

```
┌─────────────────────────────────────────────────────────────────────────┐
│  入口与 UI (Script.Core)                                                 │
│  Main：场景校验、按钮、可选引用 Grid/Entities/Player                      │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  地图管理层 (Script.Managers)                                             │
│  ChunkManager ──┬── 委托模式 ──► TilemapManager（视野驱动加载/卸载）       │
│                 └── 合并模式 ──► 自身直接：TilemapLoader + 写 Tilemap     │
│  TilemapManager：相机视野 → desired chunks → TilemapLoader/模板 → 写 Tilemap │
│  TilemapLoader：IResourceProvider + JSON → ChunkData（只读数据）          │
│  ChunkTemplateLoader：Resources/chunk_templates → ChunkData 模板池        │
│  ChunkParser：JSON 文本回退解析 tiles/blocking 数组（编辑器等用）          │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
                    ┌───────────────┼───────────────┐
                    ▼               ▼               ▼
┌──────────────────┐  ┌──────────────────┐  ┌─────────────────────────────┐
│ 工具与数据        │  │ 实体与行为        │  │ 编辑器                        │
│ Script.Utilities  │  │ Script / AI      │  │ Assets/Editor                 │
│ TileDatabase      │  │ PlayerController │  │ ChunkTemplateEditorWindow    │
│ CameraFollow      │  │ EnemyHelper     │  │ TilemapDebugWindow/Drawer    │
│ GroundManager     │  │ EnemyConfig     │  │ TilemapExporter              │
│                   │  │ IEnemyMovement  │  │                               │
│                   │  │ IEnemyAttack    │  │                               │
│                   │  │ VisualScripting │  │                               │
│                   │  │ BT_* Units      │  │                               │
└──────────────────┘  └──────────────────┘  └─────────────────────────────┘
```

---

## 二、入口与启动流程

| 阶段 | 组件 | 行为 |
|------|------|------|
| 场景加载 | **Main** | Start：绑定 Btn1/Btn2 点击；ValidateSceneStructure() 自动查找 Grid / Tilemap / Entities / Player，仅校验与提示，不强制 |
| 管理器初始化 | **ChunkManager** | Awake：创建 ResourcesProvider → IResourceProvider；查找 mainCamera、tilemapManager、groundTilemap、tileDatabase |
| 管理器初始化 | **TilemapManager** | Awake：Camera.main、ChunkTemplateLoader.Initialize(chunkWidth, chunkHeight)；查找 targetTilemap、tileDatabase |
| 实体初始化 | **PlayerController** | Awake：获取 Rigidbody2D，未找到则禁用并报错 |
| 实体初始化 | **EnemyHelper** | Awake：GetComponent\<IEnemyMovement\>、IEnemyAttack；自动查找 Player（FindObjectOfType\<PlayerController\> 或 GameObject.Find("Player")） |
| 相机 | **CameraFollow** | 每帧 LateUpdate：target 非空时 SmoothDamp 跟随 |

**依赖关系**：Main 不直接依赖 ChunkManager/TilemapManager，仅做场景结构建议。地图运行完全由 ChunkManager +（可选）TilemapManager 驱动。

---

## 三、地图加载的两种模式（ChunkManager）

### 3.1 委托模式（默认：useMergedMode = false）

- **谁算视野**：ChunkManager.UpdateVisibleChunks() 用 mainCamera + groundTilemap 算当前视野的 chunk 范围 → 得到 `desired`（HashSet\<Vector2Int\>）。
- **谁执行加载**：不自己做加载，调用 `tilemapManager.SetDesiredChunks(desired)`，由 TilemapManager 负责：
  - 对 desired 中未加载的 chunk 调用 StartLoadChunk；
  - 若开启 unloadOutOfView，则卸载不在 desired 中的 chunk。
- **谁写 Tilemap**：TilemapManager 内部用 TilemapLoader.LoadChunkDataAsync（或 ChunkTemplateLoader 模板）得到 ChunkData，再写入 targetTilemap / blockingTilemap。
- **数据流**：ChunkManager（视野）→ TilemapManager（加载 + 写入）→ TilemapLoader / ChunkTemplateLoader → TileDatabase.GetTileById → SetTile。

### 3.2 合并模式（useMergedMode = true）

- **谁算视野**：同上，ChunkManager 算 desired。
- **谁执行加载**：ChunkManager 自己用 LRU + _loaded、_fullyLoaded、SemaphoreSlim 限制并发，对缺失 chunk 调用 StartLoadChunk(cx, cy)。
- **谁写 Tilemap**：ChunkManager 内部用 TilemapLoader.LoadChunkDataAsync 得到 ChunkData，在主线程写 groundTilemap / blockingTilemap；地表用 `data.ground`，阻挡用 `data.blocking`（按 tile id 写）。
- **数据流**：ChunkManager（视野 + 加载 + 写入）→ TilemapLoader → TileDatabase.GetTileById → SetTile。此模式不经过 TilemapManager。

---

## 四、数据与资源流

| 数据类型 | 来源 | 经手 | 用途 |
|----------|------|------|------|
| **ChunkData** | JSON（Resources 或 IResourceProvider） | TilemapLoader.LoadChunkDataAsync | tiles / ground / blocking 数组；TilemapManager 或 ChunkManager 写入 Tilemap |
| **ChunkData（模板）** | Resources/chunk_templates | ChunkTemplateLoader.Initialize + GetRandomTemplateCopy | TilemapManager 在无对应 chunk 文件时填充 |
| **Tile 实例** | TileDatabase（ScriptableObject） | GetTileById(id) | SetTile(cell, tile) 写入 Tilemap |
| **TextAsset** | IResourceProvider.LoadTextAsync | TilemapLoader | 当前实现：ResourcesProvider → Resources.Load |

ChunkData 字段约定：

- **tiles**：主瓦片 id（row-major），TilemapManager 写主 Tilemap 用。
- **ground**：兼容用地表 id，ChunkManager 合并模式写地表用。
- **blocking**：byte[]，0/1 或 tile id；TilemapManager 按 0/1 写阻挡层；ChunkManager 合并模式按 id 写。

---

## 五、实体与行为逻辑

| 组件 | 职责 | 依赖 |
|------|------|------|
| **PlayerController** | 输入 → Rigidbody2D 速度；可选 Animator 参数 | Rigidbody2D（必须） |
| **CameraFollow** | 平滑跟随 target（通常为 Player） | Transform target |
| **EnemyHelper** | 对外方法：CanSeePlayer、CanAttack、MoveTowards、DoAttack；内部用 EnemyConfig + IEnemyMovement / IEnemyAttack | config (EnemyConfig)、player (Transform)、可选接口实现 |
| **BT_* Units** | Visual Scripting 节点：找最近目标、移动、判断距离、播放动画 | GameObject / 组件 |

敌人流程（典型）：Visual Scripting 或外部逻辑调用 EnemyHelper.CanSeePlayer / CanAttack → 若在范围内则 MoveTowards 或 DoAttack；具体移动/攻击可由同 GameObject 上的 IEnemyMovement / IEnemyAttack 实现。

---

## 六、命名空间与程序集

| 命名空间 | 用途 | 典型类型 |
|----------|------|----------|
| Script.Core | 入口、资源抽象 | Main, IResourceProvider, ResourcesProvider |
| Script.Managers | 地图与 chunk | ChunkManager, TilemapManager, TilemapLoader, ChunkParser, ChunkTemplateLoader |
| Script.Utilities | 通用工具与数据 | TileDatabase, CameraFollow, GroundManager |
| Script.Player | 玩家 | PlayerController |
| Script / Script.AI | 敌人与 AI 接口 | EnemyHelper, EnemyConfig, IEnemyMovement, IEnemyAttack |
| Script.VisualScripting.Units.Actions | 行为树节点 | BT_FindNearestTargetUnit, BT_MoveToUnit, BT_IsInRangeUnit, BT_PlayAnimUnit |

根目录薄包装（Script.ChunkManager、Script.TilemapManager）仅继承 Script.Managers 对应类，用于场景/预制体引用兼容，无额外逻辑。

---

## 七、地图刷新要点

- **ChunkManager（委托模式）**：每帧 `Update()` 调用 `UpdateVisibleChunks()`，用 `mainCamera` + `groundTilemap` 算视野 chunk 范围，再调用 `tilemapManager.SetDesiredChunks(desired)`。刷新频率：每帧。
- **TilemapManager**：  
  - 被 ChunkManager 委托时：不自己算视野，只响应 `SetDesiredChunks(desired)`，对缺失 chunk 调用 `StartLoadChunk`，对超出视野的 chunk 调用 `UnloadChunk`（取消加载、清除该块瓦片并从 _records 移除，以便再次进入视野时能重新加载）。  
  - 单独使用时：每帧 `Update()` 调用 `RefreshVisibleChunks().Forget()`，按当前相机视野做加载/卸载，确保离开视野的 chunk 被回收。
- **ChunkManager（合并模式）**：每帧算视野，自己用 `TilemapLoader.LoadChunkDataAsync` 加载并写 `groundTilemap`/`blockingTilemap`，卸载时用 `SetTilesBlock(bounds, null)` 清空对应块（延后一帧执行）。
- **尺寸一致**：委托模式下，ChunkManager 的 `chunkSize` 与 TilemapManager 的 `chunkWidth`/`chunkHeight` 必须一致（建议均为 32），否则同一 (cx,cy) 指向的格子范围会错位。请在 Inspector 中保持一致。

---

## 八、设计应该是怎样（推荐用法）

### 8.1 场景里应怎样摆

- **推荐**：一个场景里要么「ChunkManager + TilemapManager」一起用（委托模式），要么「只用 TilemapManager」。
  - **ChunkManager + TilemapManager**：ChunkManager 挂到例如 Managers 节点，`tilemapManager` 引用指向场景里的 TilemapManager；`useMergedMode = false`；TilemapManager 的 `targetTilemap`/`blockingTilemap` 指向 Grid 下的地表/阻挡 Tilemap；两者 **chunk 尺寸一致**（如都是 32）。
  - **只用 TilemapManager**：不挂 ChunkManager，TilemapManager 每帧自己算视野并加载/卸载，逻辑自洽。
- **不推荐**：同时挂两个且 ChunkManager 用合并模式（useMergedMode = true）又挂着 TilemapManager——会重复算视野、两套加载逻辑，容易混淆。若用合并模式，就不要再挂 TilemapManager，由 ChunkManager 单独负责写 Tilemap。

### 8.2 谁按什么驱动“有效范围”

- **有效范围 = 当前相机视野 + 一圈 padding**，不是 Player 坐标。
- 相机通常由 **CameraFollow** 跟 Player，所以**效果上**是“跟着玩家刷新”；若相机不跟 Player，则跟着相机视野刷新。
- 无论委托还是单独 TilemapManager，都应**每帧**根据当前视野更新 desired、并卸载视野外 chunk，这样“离开有效范围后会回收”才成立。

### 8.3 数据来源（chunk 内容）

- **ChunkManager 合并模式**：从 **TilemapLoader.LoadChunkDataAsync** 按路径（如 `Maps/mapName_cx_cy`）拉 JSON，得到 ChunkData 后写 Tilemap；可配合 Resources 下按坐标命名的 chunk 文件。
- **TilemapManager（含被委托时）**：当前实现**仅用 ChunkTemplateLoader 的模板**（Resources/chunk_templates）随机填充，**未从 JSON 文件按坐标加载**。若以后需要“按坐标读文件 + 无文件时用模板”，可在 TilemapManager.LoadChunkInternal 里先调 TilemapLoader.LoadChunkDataAsync，失败再走模板。

### 8.4 小结（设计应对齐的点）

| 项目 | 设计应满足 |
|------|------------|
| 视野驱动 | 按**相机**视野算 desired，每帧更新 |
| 卸载与回收 | 视野外 chunk 必须 UnloadChunk：清瓦片、从记录移除，便于再次进入时重载 |
| 委托 vs 合并 | 二选一：委托 = ChunkManager 算视野 + TilemapManager 加载/写/卸；合并 = ChunkManager 包办 |
| 尺寸一致 | ChunkManager.chunkSize 与 TilemapManager.chunkWidth/chunkHeight 一致 |
| 数据源 | 合并模式可走 JSON 文件；TilemapManager 当前仅模板，可按需扩展为“文件优先+模板回退” |

---

## 九、小结

- **入口**：Main 做 UI 与场景校验；地图不依赖 Main，由 ChunkManager（或仅 TilemapManager）每帧驱动。
- **地图**：视野按**相机**算、每帧更新；委托模式 = ChunkManager 算视野 + TilemapManager 加载/写/卸；合并模式 = ChunkManager 包办；单独使用 = TilemapManager 每帧自己算视野并加载/卸载。离开视野的 chunk 必须卸载并清瓦片，以便回收和再次加载。
- **数据**：ChunkData 来自 TilemapLoader（按文件）或 ChunkTemplateLoader（模板）；Tile 来自 TileDatabase；IResourceProvider 抽象资源加载。
- **实体**：Player + CameraFollow；Enemy 通过 EnemyHelper + 接口 + VisualScripting BT_* 完成感知与行为。

以上为当前工程的实现逻辑与**设计应对齐的形态**；具体推荐用法见第八节。
